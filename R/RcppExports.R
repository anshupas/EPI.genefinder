# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

index <- function(mat) {
    .Call('_EPI_genefinder_index', PACKAGE = 'EPI.genefinder', mat)
}

emission_table <- function(index, emissionPars) {
    .Call('_EPI_genefinder_emission_table', PACKAGE = 'EPI.genefinder', index, emissionPars)
}

emission_update <- function(index, posteriors, seqlens, nthreads) {
    .Call('_EPI_genefinder_emission_update', PACKAGE = 'EPI.genefinder', index, posteriors, seqlens, nthreads)
}

#' Forward-backward algorithm
#'
#' Forward-backward algorithm using the scaling technique.
#' That's more stable (and maybe even faster) than the method with the logarithm.
#' Warning: this function overwrites the lliks matrix.
#' @param initP matrix of initial probabilities: each column corresponds to a sequence
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @param posteriors the posteriors matrix where the posteriors will be written.
#' its value when the function is called does not matter, but it needs to have
#' the right dimensions (rows are states and columns are observations).
#' @param nthreads number of threads used. Sequences of observations are
#' processed independently by different threads (if \code{length(seqlens) > 1}).
#' @return a list with the following arguments:
#'    \item{posteriors}{posterior probability of being in a certain state for a certain datapoint.
#'     Same matrix used as input argument.}
#'    \item{tot_llik}{total log-likelihood of the data given the hmm model.}
#'    \item{new_trans}{update for the transition probabilities (it is already normalized).}
#' @export
forward_backward <- function(initP, trans, lliks, seqlens, posteriors, nthreads = 1L) {
    .Call('_EPI_genefinder_forward_backward', PACKAGE = 'EPI.genefinder', initP, trans, lliks, seqlens, posteriors, nthreads)
}

forward_backward_from_index <- function(initP, trans, map, emissionProb, seqlens, posteriors, nthreads = 1L) {
    .Call('_EPI_genefinder_forward_backward_from_index', PACKAGE = 'EPI.genefinder', initP, trans, map, emissionProb, seqlens, posteriors, nthreads)
}

#' Viterbi algorithm
#'
#' Standard viterbi algorithm in the log space
#' @param initP matrix of initial probabilities: each column corresponds to a sequence
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'    \item{vpath}{viterbi path}
#'    \item{vllik}{log-likelihood of the viterbi path}
#' @export
viterbi <- function(initP, trans, lliks, seqlens) {
    .Call('_EPI_genefinder_viterbi', PACKAGE = 'EPI.genefinder', initP, trans, lliks, seqlens)
}

viterbi_from_index <- function(initP, trans, map, emissionProb, seqlens) {
    .Call('_EPI_genefinder_viterbi_from_index', PACKAGE = 'EPI.genefinder', initP, trans, map, emissionProb, seqlens)
}

